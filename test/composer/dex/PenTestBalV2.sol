// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {console} from "forge-std/console.sol";
import {IERC20All} from "test/shared/interfaces/IERC20All.sol";
import {BaseTest} from "test/shared/BaseTest.sol";
import {Chains, Tokens, Lenders} from "test/data/LenderRegistry.sol";
import {CalldataLib} from "test/composer/utils/CalldataLib.sol";
import {ComposerPlugin, IComposerLike} from "plugins/ComposerPlugin.sol";
import {FlashLoanIds} from "contracts/1delta/composer/enums/DeltaEnums.sol";
import {SweepType, DexPayConfig} from "light/enums/MiscEnums.sol";

contract BalV2FlashLoanAttackTest is BaseTest {
    using CalldataLib for bytes;

    address internal constant BALANCER_V2_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address internal constant SWAAP = 0x03C01Acae3D0173a93d819efDc832C7C4F153B06;
    uint256 internal constant forkBlock = 26696865;
    IComposerLike internal oneDV2;

    address internal USDC;
    address internal WETH;
    address internal victim;
    address internal attacker;

    Attack1 attckPool1;
    Attack2 attckPool2;

    function setUp() public virtual {
        // initialize the chain
        string memory chainName = Chains.BASE;

        _init(chainName, forkBlock, true);
        WETH = chain.getTokenAddress(Tokens.WETH);
        USDC = chain.getTokenAddress(Tokens.USDC);
        oneDV2 = ComposerPlugin.getComposer(chainName);

        // Setup victim and attacker
        victim = makeAddr("victim");
        attacker = makeAddr("attacker");

        // Give victim some tokens and approve the composer
        deal(WETH, victim, 10 ether);
        vm.prank(victim);
        IERC20All(WETH).approve(address(oneDV2), type(uint256).max);

        // Deploy malicious contracts
        attckPool1 = new Attack1(victim, attacker, WETH, address(oneDV2), 1.0009e18); // 1 eth + fee
        deal(WETH, address(attckPool1), 100 ether); // send some weth to the pool

        attckPool2 = new Attack2(victim, attacker, WETH, address(oneDV2), 1.0009e18); // 1 eth + fee
        deal(WETH, address(attckPool2), 100 ether); // send some weth to the pool
    }

    function test_light_balancer_v2_pen_test_direct() external {
        // Amount to flash loan
        uint256 flashAmount = 1 ether;

        // encode malicios pool data
        bytes memory maliciousPool = abi.encodePacked(
            CalldataLib.swapHead(10, 0, WETH).attachBranch(0, 0, new bytes(0)),
            CalldataLib.encodeUniswapV2StyleSwap(USDC, attacker, 0, address(attckPool1), 9970, DexPayConfig.PRE_FUND, new bytes(1111))
        );

        // Create flash loan call
        bytes memory flashLoanCall = CalldataLib.encodeBalancerV2FlashLoan(WETH, flashAmount, uint8(0), maliciousPool);

        // Execute attack
        vm.prank(attacker);
        vm.expectRevert();
        oneDV2.deltaCompose(flashLoanCall);
    }

    function test_light_balancer_v2_pen_test_crossover() external {
        // Amount to flash loan
        uint256 flashAmount = 1 ether;

        // encode malicios pool data
        bytes memory maliciousPool = abi.encodePacked(
            CalldataLib.swapHead(10, 0, WETH).attachBranch(0, 0, new bytes(0)),
            CalldataLib.encodeUniswapV2StyleSwap(USDC, attacker, 0, address(attckPool2), 9970, DexPayConfig.PRE_FUND, new bytes(1111))
        );

        // Create flash loan call
        bytes memory flashLoanCall = CalldataLib.encodeBalancerV2FlashLoan(WETH, flashAmount, uint8(0), maliciousPool);

        // Execute attack
        vm.prank(attacker);
        vm.expectRevert();
        oneDV2.deltaCompose(flashLoanCall);
    }
}

// Helper contracts

abstract contract BasePoolV2 {
    address public victim;
    address public attacker;
    address public tokenToSteal;
    IComposerLike public composer;
    uint256 public flashLoanRepayAmount;
    address internal constant FACTORY = 0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6;
    address internal constant BALANCER_V2_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address internal constant SWAAP = 0x03C01Acae3D0173a93d819efDc832C7C4F153B06;

    constructor(address _victim, address _attacker, address _tokenToSteal, address _composer, uint256 _flashLoanRepayAmount) {
        victim = _victim;
        attacker = _attacker;
        tokenToSteal = _tokenToSteal;
        composer = IComposerLike(_composer);
        flashLoanRepayAmount = _flashLoanRepayAmount;
    }

    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        return (1156865411772232563819, 1695099113977, 1743777051);
    }

    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external {
        _attemptAttack();
    }

    function _attemptAttack() internal virtual;

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        IERC20All(tokenToSteal).transferFrom(from, to, value);
        return true;
    }
}

contract Attack1 is BasePoolV2 {
    constructor(
        address _victim,
        address _attacker,
        address _tokenToSteal,
        address _composer,
        uint256 _flashLoanRepayAmount
    )
        BasePoolV2(_victim, _attacker, _tokenToSteal, _composer, _flashLoanRepayAmount)
    {}

    function _attemptAttack() internal override {
        // transfer the victim's balance to oneD
        bytes memory transferToOneD = CalldataLib.encodeTransferIn(tokenToSteal, victim, 0);
        // sweep all the oneD's balance to attacker
        bytes memory sweepToAttacker = CalldataLib.encodeSweep(tokenToSteal, attacker, 0, SweepType.VALIDATE);
        // we should send the repay amount to oneD, so it can repay the flash loan,
        // the contract will never reaches this point and reverts beforehand, but a correct calldata should have it
        bytes memory getRepayAmount = CalldataLib.encodeTransferIn(tokenToSteal, address(this), flashLoanRepayAmount);
        // transfer the repay amount to balancer vault
        bytes memory repayCall = CalldataLib.encodeSweep(tokenToSteal, BALANCER_V2_VAULT, flashLoanRepayAmount, SweepType.AMOUNT);

        bytes memory maliciousCallbackData = abi.encodePacked(transferToOneD, sweepToAttacker, getRepayAmount, repayCall);

        address[] memory tokens = new address[](1);
        tokens[0] = tokenToSteal;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = flashLoanRepayAmount;
        uint256[] memory feeAmounts = new uint256[](1);
        feeAmounts[0] = 0;
        (bool success,) = address(composer).call(
            abi.encodeWithSelector(IFlashLoanRecipient.receiveFlashLoan.selector, tokens, amounts, feeAmounts, maliciousCallbackData)
        );
    }
}

contract Attack2 is BasePoolV2 {
    constructor(
        address _victim,
        address _attacker,
        address _tokenToSteal,
        address _composer,
        uint256 _flashLoanRepayAmount
    )
        BasePoolV2(_victim, _attacker, _tokenToSteal, _composer, _flashLoanRepayAmount)
    {}

    function _attemptAttack() internal override {
        // transfer the victim's balance to oneD
        bytes memory transferToOneD = CalldataLib.encodeTransferIn(tokenToSteal, victim, 0);
        // sweep all the oneD's balance to attacker
        bytes memory sweepToAttacker = CalldataLib.encodeSweep(tokenToSteal, attacker, 0, SweepType.VALIDATE);
        // we should send the repay amount to oneD, so it can repay the flash loan,
        // the contract will never reaches this point and reverts beforehand, but a correct calldata should have it
        bytes memory getRepayAmount = CalldataLib.encodeTransferIn(tokenToSteal, address(this), flashLoanRepayAmount + 1000_000);
        // transfer the repay amount to balancer vault
        bytes memory repayCall = CalldataLib.encodeSweep(tokenToSteal, BALANCER_V2_VAULT, flashLoanRepayAmount, SweepType.AMOUNT);
        // repay swaap flashloan
        bytes memory repaySwaapFlashloan = CalldataLib.encodeSweep(tokenToSteal, SWAAP, 1000_000, SweepType.AMOUNT);

        bytes memory maliciousCallbackData = abi.encodePacked(transferToOneD, sweepToAttacker, getRepayAmount, repayCall, repaySwaapFlashloan);

        // prepare swaap flashloan call

        address[] memory tokens = new address[](1);
        tokens[0] = tokenToSteal;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 1000_000;
        uint256[] memory feeAmounts = new uint256[](1);
        feeAmounts[0] = 0;
        IVault(SWAAP).flashLoan(IFlashLoanRecipient(address(composer)), tokens, amounts, maliciousCallbackData);
    }
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(address[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external;
}

interface IVault {
    function flashLoan(IFlashLoanRecipient recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}
